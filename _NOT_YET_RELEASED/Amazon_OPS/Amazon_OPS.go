package Amazon_OPS

import (

	// -=-= NATIVE LIBS

        //  VERSION FOR AMAZON_OPS == Sept 6, 2019

//	"bytes"
	"flag"
//	"io/ioutil"
//	"net/http"
	"os"
	"strconv"
	"strings"
	"time"

	// -=-= COMMON / Personal LIBS
	. "TerryCommon"

	// -=-= 3RD Party Libs

	"github.com/aws/aws-sdk-go/aws"
	"github.com/aws/aws-sdk-go/aws/credentials"
	"github.com/aws/aws-sdk-go/aws/session"
	"github.com/aws/aws-sdk-go/service/ec2"
	"github.com/aws/aws-sdk-go/aws/credentials/stscreds"
//	"github.com/aws/aws-sdk-go/aws/awserr"
)

// var GLOBAL_SESS *session.Session   // General purpose SESSION object
var AWS_OBJ *ec2.EC2		// General Purpose AWS Obj

var GLOBAL_AWS_OBJ   *ec2.EC2		// General Purpose AWS Obj

var GLOBAL_ACCESS = "" // THe AWS ACCESS KEY if passed
var GLOBAL_SECRET = "" // The AWS SECRET key if passed
var GLOBAL_REGION = "" // the us-east-1 or us-east-2 region name
var GLOBAL_ROLE = ""	// The Role we use.. this can be overridden
var GLOBAL_ARN = ""    // When using SwitchRole, this is the Global ARN (of the role) .. it is autogenerated and based on ACCOUNT and GLOBAL_ROLE

var DYNAMO_TABLE = ""    // This is the dynamo table we use (if needed) 
var DYNAMO_REGION = ""   //This is the dynamo DB table region (if needed)

var RUNNING_IN_LAMBDA = false		// This is a flag that is set when we are running by way of a LAMBDA call
var SKIP_LAMBDA = false				// If this is ever set, we DONT run in Lambda mode (RUNNING_IN_LAMBDA is set to false)
var LAMBDA_SUCCESS_MESSAGE = "Completed Lambda Successfully!!"




type DYNAMO_Item struct {
    ACC_ID  string
}

var ERR error // General purpose error handling opject

// Here are some common AWS params which we can use to init the session
var AWS_ACCESS_ENV_NAME = ""
var AWS_SECRET_ENV_NAME = ""
var AWS_TOKEN_ENV_NAME = "" 
var AWS_REGION_ENV_NAME = "" 

var AWS_DATE_FORMAT = "2006-01-02T15:04:05.000Z" //1b. This is the "FORMAT" that the AMI CreationTag uses. Specify this so the time.Time library knows how to translate the AWS date

var CURR_DATE = ""
var CURR_WEEKDAY = ""

var PREFIX = " *_*_* "
var PREF_2x = PREFIX + PREFIX


func AWS_QUEUE_PARAMS() {
	COMMON_AWS_PARAMS_INIT()	
}

func COMMON_AWS_PARAMS_INIT() {

	//1. Define the common command line params we use for AWS connectivity

	flag.StringVar(&GLOBAL_ACCESS, "access", GLOBAL_ACCESS, "       AWS Access key we want to use (takes precedence if specified)")
	flag.StringVar(&GLOBAL_SECRET, "secret", GLOBAL_SECRET, "       The AWS Secret Key  (takes precedence if specified)")
	flag.StringVar(&GLOBAL_REGION, "region", GLOBAL_REGION, "       The AWS REGION")	
	flag.StringVar(&GLOBAL_ROLE, "role", GLOBAL_ROLE, "       The ROLE we use when doing switch_role")
	flag.BoolVar(&SKIP_LAMBDA, "nolambda", SKIP_LAMBDA,  "       If specified we run in NON-LAMBDA exec mode (as a regular Script)")
	flag.BoolVar(&SKIP_LAMBDA, "skiplambda", SKIP_LAMBDA,  "       alias for --nolambda")
	flag.StringVar(&DYNAMO_TABLE, "table", DYNAMO_TABLE,  "       Name of the Dynamo DB table we want to use/create")

} //end of func


func SECONDARY_INIT_AWS() {
	COMMON_AWS_VALIDATION_TASKS()
}

// Some tasks we need to run after we have parsed AMAZON Command line params
func COMMON_AWS_VALIDATION_TASKS() {
	//1. If neither ACCESS/SECRET and PROFILE are supplied.. we default to the ENVIRONMENT variables
	if GLOBAL_ACCESS == "" && GLOBAL_SECRET == "" {

		GLOBAL_ACCESS = os.Getenv(AWS_ACCESS_ENV_NAME)
		GLOBAL_SECRET = os.Getenv(AWS_SECRET_ENV_NAME)
		GLOBAL_REGION = os.Getenv(AWS_REGION_ENV_NAME)

		// //3b. If they are STILL blank... we have a problem..
		// if GLOBAL_ACCESS == "" && GLOBAL_SECRET == "" {
		// 	R.Println(" ERROR: No valid AWS credentials were FOUND!!! I cant find any of:")
		// 	R.Println(" I MUST have at least one of the following to proceed:\n")

		// 	Y.Println("-- Option 1 use environment vars:\n")
		// 	C.Print("    export ")
		// 	M.Print(AWS_ACCESS_ENV_NAME)
		// 	W.Println("=[your aws access key]")
		// 	C.Print("    export ")
		// 	M.Print(AWS_SECRET_ENV_NAME)
		// 	W.Println("=[your aws SECRET]")
		// 	C.Print("    export ")
		// 	M.Print(AWS_TOKEN_ENV_NAME)
		// 	W.Println("=[your aws TOKEN]")

		// 	Y.Print("\n-- Option 2 specify params:\n\n ")
		// 	C.Print("   --access ")
		// 	W.Print("[YOUR ACCESS]")
		// 	C.Print(" --secret ")
		// 	W.Println("[YOUR SECRET]")
		// 	Y.Print("\n-- Option 3 Specify a profile in the .aws/credentials file:\n\n ")
		// 	C.Print("   --profile ")
		// 	W.Print("[.aws/credentials PROFILE]")

		// 	Y.Println("\n")
		// 	os.Exit(0)
		// }
	}

	//2. For the Role
	if GLOBAL_ROLE == "" {
		alt_env_role, f_exists := os.LookupEnv("DEST_ACCOUNTS_ASSUME_ROLE")
		aws_env_role, g_exists := os.LookupEnv("AWS_ROLE")
		
		// Because im using an alternate value for ASSUME role.. lets check for it first
		if f_exists {
			GLOBAL_ROLE = alt_env_role

		} else if g_exists {
		
			GLOBAL_ROLE = aws_env_role
		}		
	}

	//3. For the dynamo table and region
	if DYNAMO_REGION == "" {
		dyn_env_reg, g_exists := os.LookupEnv("DYNAMO_REGION")
		if g_exists {
			DYNAMO_REGION = dyn_env_reg
		}		
	}	
	if DYNAMO_TABLE == "" {
		dtable, g_exists := os.LookupEnv("DYNAMO_TABLE")
		if g_exists {
			DYNAMO_TABLE = dtable
		}		
	}	


	//4. Also, lets init the Nice Region List we made.. This way we can get a region Name using either ID or aa nice name
	SEARCH_REGIONS("")

	//5. If SKIP_LAMBDA is specified, lets be sure to set this to FALSE

	if SKIP_LAMBDA {
		RUNNING_IN_LAMBDA = false
	}

	//6. Finally.. Lets init the AWS SessioN Object
	INIT_AWS_SESSION(GLOBAL_REGION, "")


} //end






// This starts a new AWS Session with the already set ACCESS , Secret and TOKEN values
// Saves it to the SESS object
/*
	Standardized AWS Session INit.. Supports:

		- initializing a basic session with CREDENTIALS
		- Initializing a session using SWITCH ROLE

		Always returns a VALID AWS_OBJ..

		NOTE: Extra Args MUST be in this order
		ACCOUNT_ID, ROLE_NAME
*/
func INIT_AWS_SESSION(REGION string, EXTRA_ARGS ...string) *ec2.EC2 {

	var TEMP_AWS_OBJ *ec2.EC2
	var ACCOUNT_ID = ""
	var ROLE_NAME = ""

	//1. Parse out EXTRA_ARGS
	for i, VAL := range EXTRA_ARGS {

		// If this is 0, means its the ACCOUNT _ID
		if i == 0 {
			ACCOUNT_ID = VAL
			continue
		}

		// if this is 1, means it is the ROLE_NAME
		if i == 1 {
			ROLE_NAME = VAL
		}
	}

	var LOCAL_SESS *session.Session
	var LOCAL_ERR error

	//2. If we are running in lambda, we wanna get the default session
	if RUNNING_IN_LAMBDA {
		Y.Println("  *** Attempting to connect from LAMBDA session *** ")

		LOCAL_SESS, LOCAL_ERR = session.NewSession(&aws.Config{
			Region:      aws.String(REGION),
		})


	// Else lets connect using Credentials		
	} else {

		C.Println("\n   *** Attempting to Connect to AWS using CREDENTIALS *** ")
		LOCAL_SESS, LOCAL_ERR = session.NewSession(&aws.Config{
			Region:      aws.String(REGION),
			Credentials: credentials.NewStaticCredentials(GLOBAL_ACCESS, GLOBAL_SECRET, ""),
		})
	}

	//2b. Make sure we didnt get an error
	if LOCAL_ERR != nil {
		R.Println(" Error Establishing AWS Session!")
		return TEMP_AWS_OBJ
	}

	//3. Now.. if an account is passed, we probably need to SWITCH role 
	// We already have a session open at this point
	// Returns the AWS_OBJ and sets it as a global 

	if ACCOUNT_ID != "" {

		Y.Print("   *** Attempting SWITCH to ROLE in ACCOUNT: ")
		C.Print(ACCOUNT_ID)
		Y.Print(" ROLE: ")
		C.Println(ROLE_NAME)

		role_arn := "arn:aws:iam::" + ACCOUNT_ID + ":role/" + ROLE_NAME
		SWROLE_creds := stscreds.NewCredentials(LOCAL_SESS, role_arn)

		TEMP_AWS_OBJ = ec2.New(LOCAL_SESS, &aws.Config{
			Region: aws.String(REGION),
			Credentials: SWROLE_creds,
		})

	//4. Lets  establish an AWS OBJ directly
	} else {

		//4b. Now init the AWS_OBJ
		TEMP_AWS_OBJ = ec2.New(LOCAL_SESS)
	}

	//5. ERR handling two.. lets make sure we can describe security groups (as a safety to make sure our session connection worked)

	input := &ec2.DescribeSecurityGroupsInput{
		GroupIds: []*string{	
		},
	}

	//7. Standardized ERROR HANDLING
	_, LOCAL_ERR = TEMP_AWS_OBJ.DescribeSecurityGroups(input)
	if ERR != nil {
		R.Println("\n ERROR: Cant validate connect to AWS (credentials may be invalid?)")
		M.Println(ERR)
		Y.Print(" ACCESS: ")
		M.Println(GLOBAL_ACCESS)
		Y.Print(" Secret: ")
		M.Println(GLOBAL_SECRET)		
		Y.Print(" REGION: ")
		M.Println(REGION)		

		if ACCOUNT_ID != "" {
			R.Println("\n  ALSO: Role or ACCOUNT ID may be invalid")
			W.Print(" ACCOUNT_ID: ")
			C.Println(ACCOUNT_ID)
			W.Print(" ROLE NAME: ")
			G.Println(ROLE_NAME)			
		}


	} else {

		G.Println("   *** CONNECTION SUCCESSFUL!!!!")
		currdate := time.Now().UTC()
		CURR_DATE, CURR_WEEKDAY = DATECONV(currdate)
		M.Print("   *** CURR DATE: ")
		C.Println(CURR_DATE, CURR_WEEKDAY, "\n")
	}


	//12. Now, return the TEMP_OBJ .. this is for when we use the switch role format
	// we also set this to a global object
	AWS_OBJ = TEMP_AWS_OBJ
	GLOBAL_AWS_OBJ = TEMP_AWS_OBJ
	return TEMP_AWS_OBJ

} // end of func



// func GET_SWITCH_ROLE_OBJECT_using_ID(ACC_ID string, reg_id string) (*ec2.DescribeSecurityGroupsOutput) {
	
// // 	//1. Return values
// // 	var result_GRP_OBJ *ec2.DescribeSecurityGroupsOutput


// // 	TEMP_SESS := session.Must(session.NewSession())

// // 	role_arn := "arn:aws:iam::" + ACC_ID + ":role/automation_svc-acc_ROLE"
// // 	SWROLE_creds := stscreds.NewCredentials(TEMP_SESS, role_arn)


// // 	TEMP_AWS_OBJ := ec2.New(TEMP_SESS, &aws.Config{
// // //		Region:      aws.String(reg_id),
// // 		Region: aws.String(reg_id),
// // 		Credentials: SWROLE_creds,
// // 	})	


// // 	C.Print("\n ATTEMPTING SWITCH to: ")
// // 	W.Print("Account|ARN: ")
// // 	M.Print(role_arn)
// // 	W.Print(" REGION: ")
// // 	G.Println("", reg_id)	

// // 	//2. Now set the global AWS_OBJ to this new Switched ROLE obj


// // 	//3. Now do a safety check of our groups in this connection.. 
// // 	result_GRP_OBJ, ERR2 := TEMP_AWS_OBJ.DescribeSecurityGroups(&ec2.DescribeSecurityGroupsInput{
// // 				//Region:      aws.String(reg_id),
// // 				//GroupIds: aws.StringSlice(GROUP_IDS),
// // 	})

// // 	//1e. If there are any errors
// // 	if ERR2 != nil {
// // 		if aerr, ok := ERR2.(awserr.Error); ok {
// // 			switch aerr.Code() {
// // 				case "InvalidGroupId.Malformed":					
// // 					fallthrough
// // 				case "InvalidGroup.NotFound":
// // 					R.Println(" WARNING. Group is NOT FOUN")

// // 			} //end of switch
// // 		}
// // 		R.Print(" ERROR IN GET_SWITCH_ROLE_OBJECT_using_ID: ")
// // 		Y.Println(ERR2)
// // 		os.Exit(-9)
// // 	}	


// // 	// W.Print("  ** DEBUG LISTING ACCOUNT:")
// // 	// C.Print(ACC_ID)
// // 	// W.Print(" REGION:")
// // 	// G.Println(reg_id)

// 			//1e.. DEBUG listing of all groups
// 	for _, grp := range result_GRP_OBJ.SecurityGroups {
// 		gname := *grp.GroupName
// 		W.Print("   Group Name: ")
// 		C.Print(gname)
// 		W.Print(" VPCID: ")
// 		G.Println(*grp.VpcId)
// 	} //end of for	

// 	return result_GRP_OBJ
// } //end of func


var REGION_QUEUE [][]string

/* This is a standardized Region Search routine.. 
	 You can pass either VIRGINIA  .. or us-east-1

	 You will always get 
	 NICENAME | Reg_ID back

	 // If you call this with no input, this simply initializes the REGION_QUEUE.. Region Queue is available globally
*/
func SEARCH_REGIONS(input string) (string, string) {

	//1. Switch input to lower
	input = strings.ToLower(input)

	//1c This runs only if we dont already have data in the array.. add new regions here
	if len(REGION_QUEUE) == 0 {

		REGION_QUEUE = [][]string{
			{"Virginia", "us-east-1"},
			{"Ohio", "us-east-2"},
			{"California", "us-west-1"},
			{"Oregon", "us-west-2"},
			{"California", "us-west-1"},
			// The following reginos MUST BE EXPLICITLY ENABLED
			// {"Sydney", "ap-southeast-2"},
			// {"Tokyo", "ap-northeast-1"},
			// {"Canada", "ca-central-1"},
			// {"China", "cn-north-1"},
			// {"Ireland", "eu-west-1"},
			// {"London", "eu-west-2"},
		}
	}

	//2. Iterate through the REG_QUEUE
	niceName := " -na- "
	regid := " -na- "

	for _, r := range REGION_QUEUE {

		t_nice := r[0]
		t_regid := r[1]

		orig := t_nice
		t_nice = strings.ToLower(t_nice)

		if strings.Contains(t_nice, input) {
			niceName = orig
			regid = t_regid
			break
		}

		if strings.Contains(t_regid, input) {
			niceName = orig
			regid = t_regid
			break
		}

	}

	return niceName, regid

}




// Returns the value of a tag
func SEARCH_TAGS (find_KEY string, TAGSOBJ []*ec2.Tag, fuzzyMatch bool) (bool, string ){
	
	for _, r := range TAGSOBJ{

		key := *r.Key
		val := *r.Value
		//lowval := strings.ToLower(*r.Value)
		
		// If fuzzy match is true, we look for something that is LIKE the find_VAL
		if key == find_KEY {

			return true, val

		}			
	} //edn of for

	return false, ""
} //end of searchtags





// Returns the value of a tag
func TAGS_CONTAIN (find_KEY string, find_VAL string, TAGSOBJ []*ec2.Tag, fuzzyMatch bool) (bool, string ){
	for _, r := range TAGSOBJ{

		key := *r.Key
		val := *r.Value
		//lowval := strings.ToLower(*r.Value)
		
		// If fuzzy match is true, we look for something that is LIKE the find_VAL
		if fuzzyMatch {

			if key == find_KEY {
				if strings.Contains(val, find_VAL) {
					return true, val
				}
			}

		} else {

			if key == find_KEY && val == find_VAL {

				return true, val
			}		
		}			
	} //edn of for

	return false, ""
} //end of FUNC


/*
	This tags an item (accepting an object id as a string)
*/
func TAG_ITEM(SESS_OBJ *ec2.EC2, object_ID string, input_key string, input_value string) {

	M.Print("  ** ATTEMPTING TO TAG Object w/ID: ")
	W.Print(object_ID)
	Y.Print(" | ", input_key)
	W.Print(" as ")
	C.Println(input_value, "\n")

	TAG_SEARCH_INPUT := &ec2.CreateTagsInput{
		Resources: []*string{
			aws.String(object_ID),
		},
		Tags: []*ec2.Tag{
			{
				Key:   aws.String(input_key),
				Value: aws.String(input_value),
			},
		},
	}

	//4. Now do the actual tag update
	_, ERR := SESS_OBJ.CreateTags(TAG_SEARCH_INPUT)

	if ERR != nil {

		R.Print(" *** ERROR: We cannot tag the ec2 item with ID: ")
		W.Println(object_ID, ERR)
	}

} //end of func

// Some Common Functions i will need in various places

func GET_SCRUBBED_KEYS() (string, string) {
	keyfirst := GLOBAL_ACCESS[0:4]
	keylast := GLOBAL_ACCESS[len(GLOBAL_ACCESS)-4:]

	secfirst := GLOBAL_SECRET[0:4]
	seclast := GLOBAL_SECRET[len(GLOBAL_SECRET)-4:]

	scrub_key := keyfirst + "****" + keylast
	scrub_secret := secfirst + "****" + seclast

	return scrub_key, scrub_secret

}


func SHOW_SCRUBBED_KEYS() {
	//2b. These are here to mostly aid in debugging..
	scrub_key, scrub_secret := GET_SCRUBBED_KEYS()

	G.Print(". . . Connecting to AWS Region: ")
	W.Print(GLOBAL_REGION)
	G.Print(" with: ")
	W.Print(scrub_key)
	G.Print(" / ")
	W.Println(scrub_secret)

}


func DATECONV(TEMPDATE time.Time)  (string, string) {
	val1, val2 := DATECONV_UTC(TEMPDATE)

	return val1, val2
}

func DATECONV_UTC(TEMPDATE time.Time) (string, string) {

	//1. Convert the inbound date to UTC
	TEMPDATE = TEMPDATE.UTC()

	curr_mon := int(TEMPDATE.Month())
	curr_day := TEMPDATE.Day()
	curr_year := TEMPDATE.Year()
	curr_WEEKDAY := TEMPDATE.Weekday().String()

	full_string := strconv.Itoa(curr_mon) + "_" + strconv.Itoa(curr_day) + "_" + strconv.Itoa(curr_year)

	return full_string, curr_WEEKDAY
}

